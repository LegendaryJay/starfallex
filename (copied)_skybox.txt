--@name Personal Build Area
--@author
--@shared
--@model models/sprops/misc/domes/size_1/dome_12x6.mdl

local floorColor = Color(334,0.9,0.35):hsvToRGB()


if SERVER then
    local chip = chip()
    --chip:setSolid(false)
    timer.create("sf update", 1, 1, function() chip:setColor(floorColor) end)
     
    
    local propMdl = "models/hunter/plates/plate8x8.mdl"
    
    -- This measures the size of the above prop
    local measuringHolo = hologram.create(Vector(), Angle(), propMdl)
    local measuringHoloSize = measuringHolo:obbSize()
    local halfWallHeight = math.max(measuringHoloSize[1],measuringHoloSize[2],measuringHoloSize[3]) * 0.5
    local halfWallWidth = math.min(measuringHoloSize[1],measuringHoloSize[2],measuringHoloSize[3]) * 0.5
    local wallBoxCenter = measuringHolo:obbCenter()
    measuringHolo:remove()
    
    local floorPos = chip:obbCenterW() - Vector(0, 0, chip:obbSize()[3] * 0.45 + halfWallWidth)

    local template = {
        front = {ang = Angle(0, -90, 90), vec = Vector(1, 0,1)},
        right = {ang = Angle(0, -0, 90), vec = Vector(0, 1, 1)},
        back = {ang = Angle(0, 90, 90), vec = Vector(-1, 0, 1)},
        left = {ang = Angle(0, 180, 90), vec = Vector(0, -1, 1)},
        top = {ang = Angle(180, 0, 0), vec = Vector(0, 0, 2)},
        bottom = {ang = Angle(0, 0, 0), vec = Vector(0, 0, 0)}
    }

    local screens = {}
    local function createScreens()
        for key, t in pairs(template) do
            local ang = t.ang
            local pos = t.vec
            local screen = prop.createComponent(floorPos + wallBoxCenter + pos * halfWallHeight, ang, "starfall_screen", propMdl, true)
            screen:linkComponent(chip)
            screen:setSolid(false)
            screen:setMaterial("editor/flat")
            screen:setDrawShadow(false)
            coroutine.yield()
        end
    end

    local screenCoroutine = coroutine.create(createScreens)
    hook.add("think", "spawnScreens", function()
        if prop.canSpawn() then 
            if coroutine.status(screenCoroutine) ~= "dead" then
                coroutine.resume(screenCoroutine)
            else 
                 hook.remove("think", "spawnScreens")
            end
        end
    end)
else
    
    
    
    local skylist = {
        "skybox/starfield",
        "skybox/sky_day01_07|",
        "skybox/sky_borealis01|",
        "skybox/sky_wasteland02|",
        "skybox/crisp|"
    }
    skySelection = 3
       
    local floorlist = {
        "phoenix_storms/pack2/train_floor",
        "phoenix_storms/ps_grass",
        "models/XQM/WoodPlankTexture",
        "sprops/sprops_grid_b",
    }
    floorSelection = 4
    
    local floorsize = 50000
    
    
    
    
    ---------------
    ---------------
    ---------------
    
    
    
    
    
    
    skyMatString = skylist[skySelection]
    floorMat = render.createMaterial(floorlist[floorSelection])
    floorDecorMat = render.createMaterial("models/npcs/personality_sphere/personality_sphere_lights03")
    
    chip = chip()
    floorPos = chip:obbCenterW() - Vector(0, 0, chip:obbSize()[3] * 0.5)
    
    
    local skyMatrix = {}
    
    skyMats = {}
    skyAngles = {
        Angle(0,0,-90),
        Angle(0,90,-90),
        Angle(0,180,-90),
        Angle(0,-90,-90),
        Angle(0,0,0),
    }
    
    skyDirs = {"rt", "bk", "lf", "ft", "up"}
    needsFormat = string.endsWith(skyMatString, "|")
    if needsFormat then
        skyMatString = string.sub(skyMatString, 1, -2)
    end
    for i = 1, 5 do
        matEnd = ""
        if needsFormat then
            matEnd = skyDirs[i]
        end
        skyMats[i] = render.createMaterial(skyMatString .. matEnd)
        
        m = Matrix()
        m:scale(Vector(1,1,1)*10)
        m:rotate(skyAngles[i])
        m:translate(Vector(-0.5,-0.5,0.5))
        skyMatrix[i] = m
    end
    
    floorMatrix = Matrix()
    floorMatrix:translate(floorPos)
    floorMatrix:scale(Vector(floorsize,floorsize, 0))
    floorMatrix:rotate(Angle(0,0,180))
    floorMatrix:translate(Vector(-0.5,-0.5,0.5)) 
    
    floorDecorMatrix = nil          
    
    textScale = 125 
    function renderScene()
        render.pushViewMatrix({
            type = "3D",
            origin = Vector(),
            znear = 1,
            zfar = 50
        })
        
        for index, m in pairs(skyMatrix) do
            render.pushMatrix(m, true)
            render.setMaterial(skyMats[index])
            render.drawTexturedRectUV(0,0,1,1,0,0,1,1)
            render.popMatrix()
        end
        render.popViewMatrix()
        

        render.pushViewMatrix({
            type = "3D",
            znear = 1,
            zfar = 50000
        })
        render.pushMatrix(floorMatrix, true)
        render.setMaterial(floorMat)
        render.setColor(floorColor)
        
        render.drawTexturedRectUV(0,0,1,1,0,0,floorsize/textScale,floorsize/textScale) -- draw the ground
        render.popMatrix()
        
        render.pushMatrix(floorDecorMatrix, true)
        render.setMaterial(floorDecorMat)
        render.setColor(Color(255,255,255,55))
        render.drawTexturedRectUV(0,0,1,1,0,0,1,1) -- draw the ground
        render.popMatrix()

        
        render.popViewMatrix()
    end
    
    local boxSize = Vector()
    hook.add("render","checkScreenSize",function()
        size = render.getScreenEntity():obbSize()
        maxSize = math.max(size[1],size[2],size[3])
        boxSize = Vector(maxSize,maxSize,maxSize)
        
        m = Matrix()
        m:translate(floorPos)
        m:scale(boxSize:setZ(0) * 1.3)
        m:rotate(Angle(0,0,180))
        m:translate(Vector(-0.5,-0.5,0.5))           
        floorDecorMatrix = m
        hook.add("render","", renderScene)
        hook.remove("render","checkScreenSize")
    end)
end