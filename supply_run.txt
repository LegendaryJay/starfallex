--@name Supply Run
--@author Lil'Tugboat
--@include https://raw.githubusercontent.com/Jacbo1/Public-Starfall/main/SafeNet/safeNet.lua as SafeNet
--@shared
local net = require("SafeNet")

local Package = class("SpawnPlatform")
function Package:initialize(entity, owner, product, controller)
    self.owner = owner
    self.product = product
    self.entity = entity
    controller:addPackage(self)
    return self
end

function Package.create(owner, pos, ang ,product, controller)   
    item = prop.create(pos, ang, product.model)
    item:setMass(product.weight)
    item:setFrozen(true)
    item:setMaterial(product.mat or "")
    item:setSkin(product.skin or 0)
    return Package:new(item, owner, product, controller)
end





local SpawnPlatform = class("SpawnPlatform")

function SpawnPlatform:initialize(name, entity, products, controller)
    self.name = name
    self.pos = entity:getPos()
    self.entity = entity
    self.ang = entity:getAngles()
    self.mdl = entity:getModel()
    self.products = products or {}
    self.queue = {}
    self.size = entity:obbSize()
    self.zoneSize = Vector(1,1,1) * math.max(self.size[1], self.size[2], self.size[3])
    self:updatePos()
    self.controller = controller
    
    net.receive(name, function(_, ply)
        index = net.readFloat()
        self:queueSpawn(ply, index)
    end)
    controller:addShop(self)
    return self
end

function SpawnPlatform:updatePos()
    self.center = self.entity:obbCenterW()
    self.pos = self.entity:getPos()
    self.ang = self.entity:getAngles()
    self.min = self.entity:obbMins()
    self.max = self.entity:obbMaxs()
end

function SpawnPlatform.create(name, pos, ang, mdl, products, controller)
    local entity = prop.create(pos, ang, mdl, true)
    return SpawnPlatform:new(name, entity, products, controller)
    
end

function SpawnPlatform:spawnPackage(owner, product) 
    pos, ang = localToWorld(product.details.spawnPos, Angle(), self.center, self.ang )
    return Package.create(owner, pos, ang, product, self.controller)
end

function SpawnPlatform:getTop()
    return self.center + self.ang:getUp() * self.size[3] * 0.5
end

function SpawnPlatform:getIsClear(nextProduct)
    local t = trace.hull(self:getTop(), self:getTop(), product.details.min, product.details.max, self.entity, nil, nil, true)
    return not t.Hit
end

function SpawnPlatform:spawnNext()
    data = table.remove(self.queue, 1)
    self:spawnPackage(data[1], self.products[data[2]])
    
end

function SpawnPlatform:processQueue()
    if #self.queue > 0 and prop.canSpawn() then
        index = self.queue[1][2]
        product = self.products[index]
        if plat:getIsClear(product) then
            self:spawnNext()
        end
    end 
end

function SpawnPlatform:queueSpawn(ply, index)
    table.insert(self.queue, {ply, index})
    if #self.queue == 1 then
        hook.add("think", self.name .. "_queue", function() self:processQueue() end)
    end
end




local ShopScreen = class("ShopScreen")
function ShopScreen:initialize(name, entity, products, controller)
    self.name = name
    self.entity = entity
    self.products = products or {}
    controller:addScreen(self)
    return self
end
function ShopScreen.create(pos, ang, mdl, spawner, controller)
    screen = prop.createComponent(pos, ang, "starfall_screen", mdl, true)
    screen:linkComponent(chip())
    screen:setMaterial("editor/flat")
    screen:setMaterial("phoenix_storms/pack2/black")
    return ShopScreen:new(spawner.name, screen, spawner.products, controller)
end




local DropPlatform = class("DropPlatform")
function DropPlatform:initialize(name, entity, controller)
    self.name = name
    self.entity = entity
    self.holo = hologram.create(Vector(), Angle(), "models/hunter/blocks/cube8x8x8.mdl", Vector())
    
    self.size = entity:obbSize()
    self.zoneSize = Vector(1,1,1) * math.max(self.size[1], self.size[2], self.size[3])
    self.zoneRadius = self.zoneSize[1] * 0.5
    self.holoScale = self.zoneSize / self.holo:obbSize()

    self.holo:setScale(self.holoScale:setX(-self.holoScale[1]))
    self.holo:setMaterial("phoenix_storms/fender_white")
    self.holo:setColor(Color(255,0, 0, 50))
    
    self:updatePos()
    self.mdl = entity:getModel()
    
    self.controller = controller
    
    hook.add("think", self.name .. "_sellCheck", function() self:sellInZone() end)
    
    controller:addShop(self)
    return self
end

function DropPlatform:updatePos()
    self.center = self.entity:obbCenterW()
    self.pos = self.entity:getPos()
    self.ang = self.entity:getAngles()
    self.min = self.entity:obbMins()
    self.max = self.entity:obbMaxs()
    
    self.zoneCenter = self.center + self.entity:getUp() * self.zoneRadius
    
    self.holo:setAngles(self.entity:getAngles())
    self.holo:setPos(self.entity:localToWorld(-self.holo:obbCenter() * self.holoScale +  Vector(0,0,self.zoneSize[3]) * 0.5))
end

function DropPlatform.create(name, pos, ang, mdl, products, controller)
    local entity = prop.create(pos, ang, mdl, true)
    return DropPlatform:new(name, entity, products, controller)
end

function DropPlatform.sell(package)
    package.entity:remove()
    controller:removePackage(package)
end

function DropPlatform:sellInZone()
    items = self.controller.packagesByDrop[self.name]
    if items then
        for index, package in ipairs(items) do
            if not package or not package.entity:isValid() then continue end
            local distSqr = (self.zoneCenter - package.entity:obbCenterW()):getLengthSqr()
            if (distSqr < self.zoneRadius ^ 2) then 
                self.sell(package)
                
            end
        end
    end
end





local Controller = class("Controller")

function Controller:initialize()
    self.queue = {}
    
    -- raw tables
    self.drops = {}
    self.screens = {}
    self.shops = {}
    self.packages = {}
    
    -- lookup tables
    self.screensByShop = {}
    self.packagesByDrop = {}
    
    
    return self
end

function Controller:addPackage(package)
    if not self.packagesByDrop[package.product.location] then
        self.packagesByDrop[package.product.location] = {}
    end
    table.insert(self.packagesByDrop[package.product.location],package)
    return table.insert(self.packages, package)
end

function Controller:removePackage(package)
    table.removeByValue(self.packagesByDrop[package.product.location], package)
    return table.removeByValue(self.packages, package)
end





function Controller:addShop(shop)        
    return table.insert(self.shops, package)
end
function Controller:addDrop(drop)        
    return table.insert(self.drops, drop)
end
function Controller:addScreen(screen)
    if not self.screensByShop[screen.name] then
        self.screensByShop[screen.name] = {}
    end   
    table.insert(self.screensByShop[screen.name], screen)
    return table.insert(self.screens, screen)
end

function Controller:spawnFactory(data)
end

function Controller:spawnNext()
--[[
    data = table.remove(self.queue, 1)
    self:spawnPackage(data[1], self.products[data[2]]--)
--]]
    
end

function Controller:processQueue()
--[[
    if #self.queue > 0 and prop.canSpawn() then
        index = self.queue[1][2]
        product = self.products[index]
        if plat:getIsClear(product) then
            self:spawnNext()
        end
    end 
]]
end

function Controller:queueSpawn(ply, index)
--[[
    table.insert(self.queue, {type, args})
    if #self.queue == 1 then
        hook.add("think", "controller_queue", function() self:processQueue() end)
    end
]]
end

    
local products = {
    {
        model = "models/props_c17/oildrum001.mdl",
        weight = 250,
        key = "oil",
        price = 20,
        --mat = "models/XQM//Deg360",
        skin = 2,
        location = "Repair Store"
    },
    {
        model = "models/props_junk/metalgascan.mdl",
        weight = 250,
        key = "gas",
        price = 20,
        location = "Gas Station"
    },
    {
        model = "models/props_c17/canister_propane01a.mdl",
        weight = 200,
        key = "diesel",
        price = 20,
        location = "Truck Station"
    },
--[[
    {
        model = "models/props/de_prodigy/concretebags4.mdl",
        weight = 200,
        key = "Concrete Pallette SM",
        price = 20
    },
    {
        model = "models/props/de_prodigy/concretebags3.mdl",
        weight = 500,
        key = "Concrete Pallette MD",
        price = 20
    },
    {
        model = "models/props/de_prodigy/concretebags2.mdl",
        weight = 650,
        key = "Concrete Pallette LG",
        price = 20
    },
    {
        model = "models/props/de_prodigy/concretebags.mdl",
        weight = 900,
        key = "Concrete Pallette XL",
        price = 20
    },   
]]
}
    

if SERVER then
    controller = Controller:new()
    plat = SpawnPlatform.create("Oil Refinery", chip():getPos() + Vector( 0, 0, 20), Angle(), "models/props_junk/wood_pallet001a.mdl", products, controller)
    ShopScreen.create(chip():getPos() + Vector(0,-60, 40), Angle( 0, 0 ,45 ), "models/sprops/rectangles_superthin/size_3_5/rect_30x30.mdl", plat, controller)
    
    

    -- Get size info for future spawning
    for index, product in ipairs(products) do
        holo = hologram.create(Vector(), Angle(), product.model)
        product.details = {
            size = holo:obbSize(),
            min = holo:obbMins(),
            max = holo:obbMaxs(),
            center = holo:obbCenter(),
            spawnPos = Vector(
                0, 
                0, 
                holo:obbSize()[3] * 0.5
            ) - holo:obbCenter() + Vector(
                0,
                0,
                plat.size[3]*0.5
            )
        }
        holo:remove()
    end
    
    removal = DropPlatform.create("Gas Station", chip():getPos() + Vector( 0, -200, 0), Angle(), "models/sprops/rectangles_superthin/size_6/rect_96x96.mdl", controller)
    removal.entity:setPhysMaterial("boulder")
    removal.entity:setMaterial("phoenix_storms/stripes")    
    
    removal = DropPlatform.create("Truck Station", chip():getPos() + Vector( 0, -400, 0), Angle(), "models/sprops/rectangles_superthin/size_6/rect_96x96.mdl", controller)
    removal.entity:setMaterial("phoenix_storms/stripes")    
    removal.entity:setPhysMaterial("boulder")
    
    
    --removal = DropPlatform.create("Repair Store", chip():getPos() + Vector( 0, -400, 0), Angle(), "models/sprops/rectangles/size_90/rect_90x90x3.mdl", controller)
    --removal.entity:setMaterial("phoenix_storms/stripes")

        hook.add("starfallUsed", "turnScreenOn", function(activator, used) 
        if used:getClass() == "starfall_screen" then
            local simpleProducts = {}
            local name
            for key, screen in pairs(controller.screens) do
                if (screen.entity != used) then continue end
                printTable(screen.products)
                for key, product in pairs(screen.products) do
                    simple = {
                        price = product.price,
                        location = product.location,
                        key = product.key,
                        weight = product.weight,
                    }
                    simpleProducts[key] = simple
                    
                end
                break
            end    
        end        
     end)
    
else
    local button = class("Button")
    function button:initialize(x, y, text, w, h)
        self.x = x
        self.y = y
        self.w = w or 300
        self.h = h or 20
        self.text = text
        self.pressed = false
    end
    function button:isHovered(cx, cy)
        return cx and cx > self.x and cx < self.x+self.w and cy > self.y and cy < self.y+self.h
    end
    function button:draw()
        render.setRGBA(127, 127, 127, 255)
        render.drawRect(20, self.y+20, 300, 2)
        if not self.pressed then
            render.setRGBA(255, 255, 255, 255)
        end
        render.drawRect(self.x, self.y, self.w, self.h)
        render.setRGBA(0, 0, 0, 255)
        render.setFont("DermaDefault")
        local offset = self.pressed and 4 or 3
        render.drawText(self.x+offset, self.y+offset, self.text)
    end
    
    local menu = class("Menu")
    function menu:initialize(products, spawnerName)
        self.buttons = {}
        self.spawnerName = spawnerName
        self.pressed = false
        for i, item in ipairs(products) do
            self.buttons[i] = button:new(20, (i-1)*30+20, string.format(
                "Buy %s for %s (Weight: %d)",
                item.key,
                "$" .. item.price,
                item.weight
            ))
        end
    end
    function menu:drawButtons()
        for i, button in ipairs(self.buttons) do
            button:draw()
        end
    end
    function menu:handleInput()
        -- Only trigger when the use key is pushed down
        if player():keyDown(IN_KEY.USE) then
            if not self.pressed then -- If use was pressed this frame but not last frame
                self.pressed = true

                local cx, cy = render.cursorPos()
                if not cx or not cy then return end

                for i, button in ipairs(self.buttons) do
                    if button:isHovered(cx, cy) then
                        self:buy(i)
                        button.pressed = true
                        break
                    end
                end
            end
        elseif self.pressed then -- Otherwise, if use was not pressed this frame, but was pressed last frame
            self.pressed = false

            for i, button in ipairs(self.buttons) do
                button.pressed = false
            end
        end
    end
    function menu:buy(index)
        net.start(self.spawnerName)
            net.writeFloat(index)
        net.send()
    end

    
    
    
    function standbyeScreeen()
        screenx, screeny = render.getResolution()
        font = render.createFont("Coolvetica", 30, nil, true)
        render.setFont(font)
        render.drawText(screenx * 0.5, screeny * 0.5, "Press the 'USE' key to shop", TEXT_ALIGN.CENTER)
    end
    
    hook.add("starfallUsed", "turnScreenOn", function(activator, used) 
        if used:getClass() == "starfall_screen" then
            local simpleProducts = {}
            local name
            for key, screen in pairs(controller.screens) do
                if (screen.entity != used) then continue end
                printTable(screen.products)
                for key, product in pairs(screen.products) do
                    simple = {
                        price = product.price,
                        location = product.location,
                        key = product.key,
                        weight = product.weight,
                    }
                    simpleProducts[key] = simple
                    
                end
                break
            end    
        end        
     end)

    
    --local myMenu = menu:new(products, "Oil Refinery")
    hook.add("render", "list", function()
        standbyeScreeen()
        --myMenu:handleInput()
        --myMenu:drawButtons()

    end)
end
