--@name Supply Run
--@author Lil'Tugboat
--@include https://raw.githubusercontent.com/Jacbo1/Public-Starfall/main/SafeNet/safeNet.lua as SafeNet
--@shared
local net = require("SafeNet")

local Package = class("SpawnPlatform")
function Package:initialize(entity, owner, product, controller)
    self.owner = owner
    self.product = product
    self.entity = entity
    self.controller = controller
    controller:addPackage(self)

    -- Determine the drop zone based on the product's location
    local dropLocation = product.location
    local dropPlatform = controller:getDropPlatform(dropLocation)
    if dropPlatform then
        dropPlatform:addPackage(self)
    end

    return self
end

function Package.create(owner, pos, ang ,product, controller)   
    item = prop.create(pos, ang, product.model)
    item:setMass(product.weight)
    item:setFrozen(true)
    item:setMaterial(product.mat or "")
    item:setSkin(product.skin or 0)
    return Package:new(item, owner, product, controller)
end
function Package:getDistance(pos)
    if self.entity and self.entity:isValid() then
        return (self.entity:getPos() - pos):getLength()
    else
        self.controller.removePackage(self)
        return 9999
    end
end

function Package:sell()
    if self.entity and self.entity:isValid() then
        self.entity:remove()
    end
end




local SpawnPlatform = class("SpawnPlatform")

function SpawnPlatform:initialize(name, entity, controller)
    self.name = name
    self.pos = entity:getPos()
    self.entity = entity
    self.ang = entity:getAngles()
    self.mdl = entity:getModel()
    self.queue = {}
    self.size = entity:obbSize()
    self.zoneSize = Vector(1,1,1) * math.max(self.size[1], self.size[2], self.size[3])
    self:updatePos()
    self.controller = controller
    self.products = controller:getProductData(self.name)
    
    net.receive(name, function(_, ply)
        index = net.readFloat()
        self:queueSpawn(ply, index)
    end)
    controller:addShop(self)
    return self
end

function SpawnPlatform:updatePos()
    self.center = self.entity:obbCenterW()
    self.pos = self.entity:getPos()
    self.ang = self.entity:getAngles()
    self.min = self.entity:obbMins()
    self.max = self.entity:obbMaxs()
end

function SpawnPlatform.create(name, pos, ang, mdl, controller)
    local entity = prop.create(pos, ang, mdl, true)
    return SpawnPlatform:new(name, entity, controller)
    
end

function SpawnPlatform:spawnPackage(owner, product) 
    pos, ang = localToWorld(product.spawnInfo.spawnPos + self.ang:getUp() * self.size[3] * 0.5, Angle(), self.center, self.ang )
    return Package.create(owner, pos, ang, product, self.controller)
end

function SpawnPlatform:getTop()
    return self.center + self.ang:getUp() * self.size[3] * 0.5
end

function SpawnPlatform:getIsClear(nextProduct)
    local t = trace.hull(self:getTop(), self:getTop(), product.spawnInfo.min, product.spawnInfo.max, self.entity, nil, nil, true)
    return not t.Hit
end

function SpawnPlatform:spawnNext()
    data = table.remove(self.queue, 1)
    self:spawnPackage(data[1], self.products[data[2]])
    
end

function SpawnPlatform:processQueue()
    if #self.queue > 0 and prop.canSpawn() then
        index = self.queue[1][2]
        product = self.products[index]
        if self:getIsClear(product) then
            self:spawnNext()
        end
    end 
end

function SpawnPlatform:queueSpawn(ply, index)
    table.insert(self.queue, {ply, index})
    if #self.queue == 1 then
        hook.add("think", self.name .. "_queue", function() self:processQueue() end)
    end
end




local ShopScreen = class("ShopScreen")
function ShopScreen:initialize(name, entity, controller)
    self.name = name
    self.entity = entity
    self.products = controller
    self.controller = controller
    
    
    net.receive("screenRequest_" .. self.entity:entIndex(), function(_, ply)
        net.start("screenInfo")
            net.writeTable(self.controller:getProductData(self.name))
            net.writeString(self.name)
        net.send(ply)
    end)

    controller:addScreen(self)
    return self
end
function ShopScreen.create(name, pos, ang, mdl, controller)
    screen = prop.createComponent(pos, ang, "starfall_screen", mdl, true)
    screen:linkComponent(chip())
    screen:setMaterial("editor/flat")
    screen:setMaterial("phoenix_storms/pack2/black")
    return ShopScreen:new(name, screen, controller)
end




local DropPlatform = class("DropPlatform")
function DropPlatform:initialize(name, entity, controller)
    self.name = name
    self.entity = entity
    self.controller = controller
    self.packages = {}

    self.holo = hologram.create(Vector(), Angle(), "models/hunter/blocks/cube8x8x8.mdl", Vector())

    self.size = entity:obbSize()
    self.zoneSize = Vector(1, 1, 1) * math.max(self.size[1], self.size[2], self.size[3])
    self.zoneRadius = self.zoneSize[1] * 0.5
    self.holoScale = self.zoneSize / self.holo:obbSize()

    self.holo:setScale(self.holoScale:setX(-self.holoScale[1]))
    self.holo:setMaterial("phoenix_storms/fender_white")
    self.holo:setColor(Color(255, 0, 0, 50))

    self:updatePos()

    self:startMonitoringPackages()
    
    controller:addDrop(self)
    return self
end

function DropPlatform:updatePos()
    self.center = self.entity:obbCenterW()
    self.pos = self.entity:getPos()
    self.ang = self.entity:getAngles()
    self.min = self.entity:obbMins()
    self.max = self.entity:obbMaxs()

    self.zoneCenter = self.center + self.entity:getUp() * self.zoneRadius

    self.holo:setAngles(self.entity:getAngles())
    self.holo:setPos(self.entity:localToWorld(-self.holo:obbCenter() * self.holoScale + Vector(0, 0, self.zoneSize[3]) * 0.5))
end

function DropPlatform.create(name, pos, ang, mdl, controller)
    local entity = prop.create(pos, ang, mdl, true)
    return DropPlatform:new(name, entity, controller)
end

function DropPlatform:addPackage(package)
    table.insert(self.packages, package)
end

function DropPlatform:startMonitoringPackages()
    hook.add("think", self.name .. "_sellCheck", function()
        self:checkAndSellPackages()
    end)
end

function DropPlatform:checkAndSellPackages()
    for _, package in ipairs(self.packages) do
        if package:getDistance(self.zoneCenter) <= self.zoneRadius then
            package:sell()
            self.controller:removePackage(package)
        end
    end
end

local Controller = class("Controller")

function Controller:initialize(products)
    self.queue = {}
    
    self.products = products
    self.productSpawnInfo = {}
    
    -- raw tables
    self.drops = {}
    self.screens = {}
    self.shops = {}
    self.packages = {}
    
    self.entityLookup = {}
    
    self:generateProductData()
    
    return self
end


function Controller:generateProductData()
        -- Get size info for future spawning
    for index, product in ipairs(self.products) do
        holo = hologram.create(Vector(), Angle(), product.model)
        info = {
            size = holo:obbSize(),
            min = holo:obbMins(),
            max = holo:obbMaxs(),
            center = holo:obbCenter(),
            spawnPos = Vector(
                0, 
                0, 
                holo:obbSize()[3] * 0.5
            ) - holo:obbCenter()
        }
        holo:remove()
        self.productSpawnInfo[index] = info
    end
end

function Controller:getProductData(startLocation)
    local filteredProducts = {}

    if startLocation then
        for index, product in ipairs(self.products) do
            for _, route in ipairs(product.routes) do
                if route[1] == startLocation then
                    local spawnInfo = self.productSpawnInfo[index]
                    table.insert(filteredProducts, {
                        model = product.model,
                        weight = product.weight,
                        key = product.key,
                        price = product.price,
                        skin = product.skin,
                        mat = product.mat,
                        location = route[2],
                        finalPrice = route[3],
                        spawnInfo = spawnInfo,
                    })
                end
            end
        end
    else
        return self.products
    end
    return filteredProducts
end



function Controller:removePackage(package)
    if package then 
        self:removeEntityInfo(package.id)
        return table.removeByValue(self.packages, package)
    end
end


function Controller:addEntityInfo(entity, type, object)
    self.entityLookup[entity:entIndex()] = {"type", object}
end

function Controller:getEntityInfo(entity)
    return self.entityLookup[entity:entIndex()]
end

function Controller:removeEntityInfo(id)
    return table.remove(self.entityLookup, id)
end


function Controller:addShop(shop)
    self:addEntityInfo(shop.entity, "shop", shop)
    return table.insert(self.shops, package)
end
function Controller:addDrop(drop)
    self:addEntityInfo(drop.entity, "drop", drop)    
    return table.insert(self.drops, drop)
end
function Controller:addScreen(screen)
    self:addEntityInfo(screen.entity, "screen", screen)   
    return table.insert(self.screens, screen)
end
function Controller:addPackage(package)
     self:addEntityInfo(package.entity, "package", package)   
    return table.insert(self.packages, package)
end

function Controller:queueComponent(type, name, pos, angle)
    -- Add the component to the queue
    table.insert(self.queue, {type, name, pos, angle})

    -- Start processing the queue if it's the first item
    if #self.queue == 1 then
        hook.add("think", "controller_queue", function() self:processQueue() end)
    end
end

function Controller:processQueue()
    -- If the queue has items and prop spawning is allowed, process the next item
    if #self.queue > 0 and prop.canSpawn() then
        self:spawnNext()
    end
end

function Controller:spawnNext()
    -- Extract the next item from the queue
    local data = table.remove(self.queue, 1)
    local type, name, pos, angle = unpack(data)

    -- Spawn the component based on the type
    if type == "DropPlatform" then
        local item = DropPlatform.create(name, pos, angle, "models/sprops/rectangles_superthin/size_6/rect_96x96.mdl", self)
        item.entity:setMaterial("phoenix_storms/stripes")    
    elseif type == "ShopScreen" then
        ShopScreen.create(name, pos, angle, "models/sprops/rectangles_superthin/size_3_5/rect_30x30.mdl", self)
    elseif type == "SpawnPlatform" then
        SpawnPlatform.create(name, pos, angle, "models/props_junk/wood_pallet001a.mdl", self)
    end

    -- Continue processing the queue
    if #self.queue > 0 then
        hook.add("think", "controller_queue", function() self:processQueue() end)
    else
        hook.remove("think", "controller_queue")
    end
end

function Controller:getDropPlatform(locationName)
    for _, drop in ipairs(self.drops) do
        if drop.name == locationName then
            return drop
        end
    end
    return nil -- Return nil if no matching drop platform is found
end

--[[
-- pickup Locations
"Oil Refinery"
"Phil's Factory"


-- drop locations
"Repair Store"
"Gas Station"
"Truck Station"
]]
    

if SERVER then
    
    local products = {
        {
            model = "models/props_junk/garbage_newspaper001a.mdl",
            weight = 5,
            key = "Documents",
            price = 10,
            --mat = "models/XQM//Deg360",
            skin = 0,
            routes = {
                {"Spawn Office", "Police Station", 20},

            }
        },
        {
            model = "models/props_vehicles/car002b_physics.mdl",
            weight = 1000,
            key = "Junk Car",
            price = 5500,
            --mat = "models/XQM//Deg360",
            skin = 0,
            routes = {
                {"Car Dealership", "Junk Shed", 12500},

            }
        },
        {
            model = "models/props_wasteland/cargo_container01.mdl",
            weight = 2500,
            key = "Shipping Container",
            price = 8000,
            --mat = "models/XQM//Deg360",
            skin = 0,
            routes = {
                {"Shipping Garage", "Junk Shed", 24500},

            }
        }
    }

    local controller = Controller:new(products)


    -- how to create stuff
    --controller:queueComponent(type, name, position, angle)
    
    -- list of types: "SpawnPlatform", "ShopScreen", "DropPlatform"
    --names look like whatever. "This is a name", "so is this"
    
    -- vectors look like this: Vector(0,0,0)
    --angles look like this: Angle(0,0,0)
    
    
    -- example command: 
    controller:queueComponent("SpawnPlatform", "Spawn Office", Vector(-10817, 6119, 1027), Angle())
    controller:queueComponent("ShopScreen", "Spawn Office", Vector(-10817, 6160, 1070), Angle(0,180,90))
    controller:queueComponent("DropPlatform", "Police Station", Vector(-7197, 7583, 1027), Angle())

    controller:queueComponent("SpawnPlatform", "Car Dealership", Vector(-7690, -9111, 1024), Angle(0,90,0))
    controller:queueComponent("ShopScreen", "Car Dealership", Vector(-8048, -9029, 1071), Angle(0,90,90))
    controller:queueComponent("DropPlatform", "Junk Shed", Vector(-6251, -8393, -515), Angle())

    controller:queueComponent("SpawnPlatform", "Shipping Garage", Vector(4895, 2564, 1088), Angle(0,90,0))
    controller:queueComponent("ShopScreen", "Shipping Garage", Vector(4895, 2564, 1088), Angle(0,90,90))
    controller:queueComponent("DropPlatform", "Port", Vector(-6251, -8393, -515), Angle())


    
else
    local button = class("Button")
    function button:initialize(x, y, text, w, h)
        self.x = x
        self.y = y
        self.w = w or 300
        self.h = h or 20
        self.text = text
        self.pressed = false
    end
    function button:isHovered(cx, cy)
        return cx and cx > self.x and cx < self.x+self.w and cy > self.y and cy < self.y+self.h
    end
    function button:draw()
        render.setRGBA(127, 127, 127, 255)
        render.drawRect(20, self.y+20, 300, 2)
        if not self.pressed then
            render.setRGBA(255, 255, 255, 255)
        end
        render.drawRect(self.x, self.y, self.w, self.h)
        render.setRGBA(0, 0, 0, 255)
        render.setFont("DermaDefault")
        local offset = self.pressed and 4 or 3
        render.drawText(self.x+offset, self.y+offset, self.text)
    end
    
    local menu = class("Menu")
    function menu:initialize(products, spawnerName)
        self.buttons = {}
        self.spawnerName = spawnerName
        self.pressed = false
        for i, item in ipairs(products) do
            self.buttons[i] = button:new(20, (i-1)*30+20, string.format(
                "Buy %s for %s (Weight: %d) Dropoff Zone: %s",
                item.key,
                "$" .. item.price,
                item.weight,
                item.location
            ))
        end
    end
    function menu:drawButtons()
        for i, button in ipairs(self.buttons) do
            button:draw()
        end
    end
    function menu:handleInput()
        -- Only trigger when the use key is pushed down
        if player():keyDown(IN_KEY.USE) then
            if not self.pressed then -- If use was pressed this frame but not last frame
                self.pressed = true

                local cx, cy = render.cursorPos()
                if not cx or not cy then return end

                for i, button in ipairs(self.buttons) do
                    if button:isHovered(cx, cy) then
                        self:buy(i)
                        button.pressed = true
                        break
                    end
                end
            end
        elseif self.pressed then -- Otherwise, if use was not pressed this frame, but was pressed last frame
            self.pressed = false

            for i, button in ipairs(self.buttons) do
                button.pressed = false
            end
        end
    end
    function menu:buy(index)
        net.start(self.spawnerName)
            net.writeFloat(index)
        net.send()
    end

    
    
    
    local isNearScreen = false
    local products = {}
    local shopName = ""
    local lastScreenUsedTime = 0
    local SCREEN_USE_COOLDOWN = 1 -- Cooldown time in seconds
    local lastEntity = chip()
    local productMenu
    
    local function standbyeScreen()
        screenx, screeny = render.getResolution()
        font = render.createFont("Coolvetica", 30, nil, true)
        render.setFont(font)
        render.drawText(screenx * 0.5, screeny * 0.5, "Press the 'USE' key to shop", TEXT_ALIGN.CENTER)
    end
    
    local function displayProductsMenu()
        productMenu:drawButtons()
        productMenu:handleInput()
    end
    
    hook.add("render", "screenRender", function()
        if productMenu and render.getScreenEntity() == lastEntity then
            displayProductsMenu()
        else
            standbyeScreen()
        end
    end)
    
    hook.add("starfallUsed", "turnScreenOn", function(activator, used)
        if activator != player() then return end
        if not activator:isPlayer() or used:getClass() ~= "starfall_screen" then
            return
        end
        lastEntity = used
        local currentTime = timer.systime()
        local timeSinceLastUse = currentTime - lastScreenUsedTime
    
        if timeSinceLastUse >= SCREEN_USE_COOLDOWN then
            lastScreenUsedTime = currentTime
            net.start("screenRequest_" .. used:entIndex())
            net.send()
        end
    end)
    
    net.receive("screenInfo", function()
        products = net.readTable()
        shopName = net.readString()

        productMenu = menu:new(products or {}, shopName)
        hook.add("think", "checkProximity", function()
            isNearScreen = lastEntity:isValid() and (player():getPos() - lastEntity:getPos()):getLengthSqr() < 200 ^ 2
            if not isNearScreen then
                productMenu = nil
                hook.remove("think", "checkProximity")
            end
        end)
    end)
end
