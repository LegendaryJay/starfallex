--@name Personal Build Area
--@author
--@shared
--@model models/sprops/misc/domes/size_1/dome_12x6.mdl

local floorColor = Color(334,0.9,0.35):hsvToRGB()


if SERVER then
    local chip = chip()
    --chip:setSolid(false)
    timer.create("sf update", 1, 1, function() chip:setColor(floorColor) end)
     
    
    local propMdl = "models/hunter/plates/plate32x32.mdl"
    
    -- This measures the size of the above prop
    local measuringHolo = hologram.create(Vector(), Angle(), propMdl)
    local measuringHoloSize = measuringHolo:obbSize()
    local halfWallHeight = math.max(measuringHoloSize[1],measuringHoloSize[2],measuringHoloSize[3]) * 0.5
    local halfWallWidth = math.min(measuringHoloSize[1],measuringHoloSize[2],measuringHoloSize[3]) * 0.5
    local wallBoxCenter = measuringHolo:obbCenter()
    measuringHolo:remove()
    
    local floorPos = chip:obbCenterW() - Vector(0, 0, chip:obbSize()[3] * 0.45 + halfWallWidth)

    local template = {
        front = {ang = Angle(0, -90, 90), vec = Vector(1, 0,1)},
        right = {ang = Angle(0, -0, 90), vec = Vector(0, 1, 1)},
        back = {ang = Angle(0, 90, 90), vec = Vector(-1, 0, 1)},
        left = {ang = Angle(0, 180, 90), vec = Vector(0, -1, 1)},
        top = {ang = Angle(180, 0, 0), vec = Vector(0, 0, 2)},
        bottom = {ang = Angle(0, 0, 0), vec = Vector(0, 0, 0)}
    }

    local screens = {}
    local function createScreens()
        for key, t in pairs(template) do
            local ang = t.ang
            local pos = t.vec
            local screen = prop.createComponent(floorPos + wallBoxCenter + pos * halfWallHeight, ang, "starfall_screen", propMdl, true)
            screen:linkComponent(chip)
            screen:setSolid(false)
            screen:setMaterial("editor/flat")
            screen:setDrawShadow(false)
            coroutine.yield()
        end
    end

    local screenCoroutine = coroutine.create(createScreens)
    hook.add("think", "spawnScreens", function()
        if prop.canSpawn() then 
            if coroutine.status(screenCoroutine) ~= "dead" then
                coroutine.resume(screenCoroutine)
            else 
                 hook.remove("think", "spawnScreens")
            end
        end
    end)
else
    
    
    local skylist = {
        "skybox/starfield",
        "skybox/sky_day01_07|",
        "skybox/sky_borealis01|",
        "skybox/sky_wasteland02|",
        "skybox/crisp|"
    }
    skySelection = 3
       
    local floorlist = {
        "phoenix_storms/pack2/train_floor",
        "phoenix_storms/ps_grass",
        "models/XQM/WoodPlankTexture",
        "sprops/sprops_grid_b",
    }
    floorSelection = 4
    
    local floorsize = 50000
    
    
    
    
    ---------------
    ---------------
    ---------------
    
    chip = chip()
    floorPos = chip:obbCenterW() - Vector(0, 0, chip:obbSize()[3] * 0.5)
    
    ufoScale = 2
    
    ufoPos =  Vector(0,0,1000 + ufoScale * 100 )
    invisUFO = false
    ufoHolos = {}
    UFOTop = hologram.create(ufoPos + Vector(0,0,-10) * ufoScale, Angle(), "models/sprops/misc/domes/size_4/dome_48x24.mdl")
    UFOTop:setScale(Vector(20,20,5) * ufoScale)
    UFOTop:setMaterial("debug/env_cubemap_model_translucent")
    UFOTop:setNoDraw(invisUFO)
    table.insert(ufoHolos, UFOTop)
    
    UFOBottom = hologram.create(ufoPos + Vector(0,0,10) * ufoScale, Angle(180,0,0), "models/sprops/misc/domes/size_4/dome_48x24.mdl")
    UFOBottom:setScale(Vector(20,20,5) * ufoScale)
    UFOBottom:setMaterial("debug/env_cubemap_model_translucent")
    UFOBottom:setParent(UFOTop)
    UFOBottom:setNoDraw(invisUFO)
    table.insert(ufoHolos, UFOBottom)
    
    spinnerCenter = ufoPos- Vector(0,0,80) * ufoScale
    spinner = hologram.create(spinnerCenter , Angle(180,0,0), "models/sprops/misc/domes/size_4/dome_48x24.mdl")
    spinner:setScale(Vector(1,1,0.5) * 6 * ufoScale)
    spinner:setMaterial("phoenix_storms/chrome")
    spinner:setParent(UFOTop)
    spinner:setNoDraw(invisUFO)
    table.insert(ufoHolos, spinner)
    
--[[
    distFromCenter = ufoPos:getDistance(floorPos)
    beam = ufoPos - Vector(0,0,80)
    beam = hologram.create(ufoPos - Vector(0,0,distFromCenter), Angle(0,0,0), "models/sprops/misc/cones/size_4/cone_48x144.mdl")
    beam:setSize( Vector(480, 480, distFromCenter))
    beam:setMaterial("models/debug/debugwhite" )
    beam:setColor(Color(200,0,150, 50))
    beam:setNoDraw(true)
    table.insert(ufoHolos, beam)
]]
    
    ballCount = 5
    for i = 1, ballCount do
        percent = i/ballCount
        angle = 6.282 * percent
        radius = 100
        holoVec = spinnerCenter- Vector(math.sin(angle) * radius,math.cos(angle) * radius,50) * ufoScale
        holo = hologram.create(holoVec , Angle(), "models/hunter/misc/sphere075x075.mdl")
        holo:setMaterial("debug/debugtranslucentsinglecolor")
        holo:setScale(Vector(1,1,1) * 2 * ufoScale)
        holo:setAngles(-(holo:getPos() + spinner:getPos()):getAngle())
        holo:setParent(spinner)
        holo:setNoDraw(invisUFO)
        table.insert(ufoHolos, holo)
    end
    
    local time = 0
    local wobbleSpeed = 1 -- Speed of the wobble motion
    local wobbleMagnitude = 2 -- Magnitude of the wobble in degrees
    local wobblePositionAmplitude = 1 -- Amplitude of the position wobble in units
    local spinSpeed = 0.05
    
    ufoAng = UFOTop:getAngles()
    spinnerAng = spinner:getAngles()
    ufoNewPos = ufoPos
    hook.add("think", "updateHolos", function() 
        
        time = time + timer.frametime() * wobbleSpeed
        local pitch = math.sin(time) * wobbleMagnitude
        local roll = math.cos(time) * wobbleMagnitude
        
        offsetX = math.sin(time * 1.5) * wobblePositionAmplitude -- Different phase for X
        offsetY = math.cos(time * 1.2) * wobblePositionAmplitude -- Different phase for Y
        offsetZ = math.sin(time * 0.8) * wobblePositionAmplitude -- Different phase for Z
        
        ufoAng = Angle(pitch, UFOTop:getAngles()[2] + spinSpeed, roll)
        spinnerAng = spinner:getAngles() - Angle(0,spinSpeed * 2 ,0)
        ufoNewPos = ufoPos + Vector(offsetX, offsetY, -10 + offsetZ)
    end)
    
    
    skyMatString = skylist[skySelection]
    floorMat = render.createMaterial(floorlist[floorSelection])
    floorDecorMat = render.createMaterial("models/npcs/personality_sphere/personality_sphere_lights03")
    
    
    local skyMatrix = {}
    
    skyMats = {}
    skyAngles = {
        Angle(0,0,-90),
        Angle(0,90,-90),
        Angle(0,180,-90),
        Angle(0,-90,-90),
        Angle(0,0,0),
    }
    
    skyDirs = {"rt", "bk", "lf", "ft", "up"}
    needsFormat = string.endsWith(skyMatString, "|")
    if needsFormat then
        skyMatString = string.sub(skyMatString, 1, -2)
    end
    for i = 1, 5 do
        matEnd = ""
        if needsFormat then
            matEnd = skyDirs[i]
        end
        skyMats[i] = render.createMaterial(skyMatString .. matEnd)
        
        m = Matrix()
        m:scale(Vector(1,1,1)*100)
        m:rotate(skyAngles[i])
        m:translate(Vector(-0.5,-0.5,0.5))
        skyMatrix[i] = m
    end
    
    floorMatrix = Matrix()
    floorMatrix:translate(floorPos)
    floorMatrix:scale(Vector(floorsize,floorsize, 0))
    floorMatrix:rotate(Angle(0,0,180))
    floorMatrix:translate(Vector(-0.5,-0.5,0.5)) 
    
    floorDecorMatrix = nil          
    
    textScale = 125 
    

    
    lastDraw = 0
    function renderScene()
        render.pushViewMatrix({
            type = "3D",
            origin = Vector(),
            znear = 1,
            zfar = 10000
        })
        
        for index, m in pairs(skyMatrix) do
            render.pushMatrix(m, true)
            render.setMaterial(skyMats[index])
            render.drawTexturedRectUV(0,0,1,1,0,0,1,1)
            render.popMatrix()
        end
        
        render.popViewMatrix()
        
        render.pushViewMatrix({
            type = "3D",
            origin = (eyePos() - chip:getPos()) * 0.3 ,
            znear = 1,
            zfar = 10000
        })
        
        
        for key, holo in pairs(ufoHolos) do
            holo:draw()
        end
        render.popViewMatrix()
        
        

        render.pushViewMatrix({
            type = "3D",
            znear = 1,
            zfar = 50000
        })
        render.pushMatrix(floorMatrix, true)
        render.setMaterial(floorMat)
        render.setColor(floorColor)
        
        render.drawTexturedRectUV(0,0,1,1,0,0,floorsize/textScale,floorsize/textScale) -- draw the ground
        render.popMatrix()
        
        render.pushMatrix(floorDecorMatrix, true)
        render.setMaterial(floorDecorMat)
        render.setColor(Color(255,255,255,55))
        render.drawTexturedRectUV(0,0,1,1,0,0,1,1) -- draw the ground
        render.popMatrix()

        
        render.popViewMatrix()

       
        
        local now = timer.curtime()
        if now - lastDraw > 0.01 then
            lastDraw = now
            UFOTop:setAngles(ufoAng)
            spinner:setAngles(spinnerAng)
            UFOTop:setPos(ufoNewPos)
        end
    
    end
    
    local boxSize = Vector()
    hook.add("render","checkScreenSize",function()
        size = render.getScreenEntity():obbSize()
        maxSize = math.max(size[1],size[2],size[3])
        boxSize = Vector(maxSize,maxSize,maxSize)
        
        m = Matrix()
        m:translate(floorPos)
        m:scale(boxSize:setZ(0) * 1.3)
        m:rotate(Angle(0,0,180))
        m:translate(Vector(-0.5,-0.5,0.5))           
        floorDecorMatrix = m
        hook.remove("render","checkScreenSize")
        
        hook.add("render","", renderScene)
    end)

end