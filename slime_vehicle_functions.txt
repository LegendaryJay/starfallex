--@name Slime Vehicle Functions
--@author Lil'Tugboat
--@server




local BinManager = class("binManager")

function BinManager:initialize(binCountSize, binDegreeSize)
    self.binCountSize = binCountSize  
    self.binDegreeeSize = binDegreeSize 
    self.bins = {}
    
    return self
end

function BinManager:add(binKey)
    self.bins[binKey] = (self.bins[binKey] or 0) + 1 
end

function BinManager:remove(binKey)
    self.bins[binKey] = (self.bins[binKey] or 0) - 1
    if self.bins[binKey] < 0 then
        throw("removed from empty bin")
    end
end

function BinManager:move(fromBinKey, toBinKey)
    if fromBinKey == toBinKey then return end
    self:remove(fromBinKey)
    self:add(toBinKey)
end


function BinManager:getBinName(angle)
    local pitch = angle[1]
    pitch = math.floor(pitch / binDegreeSize) * binDegreeSize
    
    local yaw = angle[2]
    yaw = math.floor(yaw / binDegreeSize) * binDegreeSize
    
    return pitch .. "," .. yaw
end

function BinManager:isFull(binName)
    return self.bins[binName] or 0) >= binCountSize
end


local SlimeArmManager = class("slimeArmManager")
function SlimeArmManager:initialize(body)
    self.arms = {}
    
    return self
end

function SlimeArmManager:update(key, position, entity)
    local arm = arms[key]
    arm.position = position
    

    //bin
--[[
        if #unusedHolos == 0 then
            foot.holo = holoItt
            holoItt = holoItt + 1
            holos:create(foot.holo)
            holos:setModel(foot.holo, "models/holograms/hq_icosphere.mdl")
            holos:setScale(foot.holo, Vector(1,1,1))
        else
            foot.holo = table.remove(unusedHolos, #unusedHolos)
        end
]]
        
        if entity then
            setFootAttEntity(foot,)
        else 
        
        end
        addToBin(binName)  

end

function SlimeArm:create()
        local arm = {}
        local key = table.insert(self.arms, arm) 
        self.update(key)
end    
    // be created
    // change target
    // be removed
    
    
    

    
        
    local function setFootAttEntity(hasEntity, entity, worldPos)
        if not hasEntity then
            foot.hasEntity = true
            foot.attachedEntity = nil
            foot.localEntityVector = nil
        else
            foot.hasEntity = true
            foot.attachedEntity = entity
            foot.localEntityVector = entity:worldToLocal(position)
        end    
    end
    
    local function createFoot(binName, entity, position)
        local foot = {
            binName = binName,
            position = position
        }
        if #unusedHolos == 0 then
            foot.holo = holoItt
            holoItt = holoItt + 1
            holos:create(foot.holo)
            holos:setModel(foot.holo, "models/holograms/hq_icosphere.mdl")
            holos:setScale(foot.holo, Vector(1,1,1))
        else
            foot.holo = table.remove(unusedHolos, #unusedHolos)
        end
        
        if entity then
            setFootAttEntity(foot,)
        else 

        end
        addToBin(binName)  
        table.insert(feet, foot) 
    end
    
    local function removeFoot(key)
        foot = feet[key]
        holos:setScale(foot.holo, Vector(0,0,0))
        removeFromBin(foot.binName)
        --print(2)
        table.insert(unusedHolos, foot.holo)
        --print(3)
        table.remove(feet, key)
    end
    
    local function sense()
        remainingSensors = sensorCount - #feet
        for i = 1, remainingSensors, 1 do
                -- set direction
                local direction = randomVector()
                local directionAngle = direction:getAngle()
                
                -- check bin and quit if full
                local binName = getBinName(directionAngle)
                if binIsFull(binName) then return end
                
                -- see if it hits anything, otherwise quiet
                local tracer = localTrace(direction)
                if not tracer.Hit then return end
        
                -- create foot
                createFoot(binName, tracer.Entity, tracer.HitPos)
        end

        for key, foot in pairs(feet) do
            if (foot.hasEntity == true and not isValid(foot.attachedEntity)) then -- If an entity should exist but doesnt, kill the foot
                removeFoot(key)
                continue
            end
            
            -- trace
            tracer = trace.line(chairPos, foot.position, chair)
        
            if not tracer.Hit then removeFoot(key) continue end -- if it didn't hit anything, kill the foot
            
            if tracer.Entity
                if foot.hasEntity and foot.attachedEntity == tracer.Entity then continue end -- if entity is the same, ignore and move on
                setFootAttEntity(true, tracer.Entity, tracer.HitPos)  -- otherwise, update
            else -- if no entity
                if foot.hasEntity then
                    setFootAttEntity(false)  -- then remove it if applicable
                end
                
                
                
                    
                
                
                
    
            
            
            
            if foot.attachedEntity
                    
                if foot.attachedEntity != nil and not isValid(foot.attachedEntity)
                local foot = feet[i]
                
                if tracer.Entity then
                    if foot.attachedEntity == tracer.Entity then continue end
                    
                    foot.attachedEntity = tracer.Entity
                    foot.localEntityVector = tracer.Entity:worldToLocal(position)
                else 
                    if foot.attachedEntity then continue end
                    and not foot.attachedEntity then 
                moveBins(foot)
        
        
        
        
        
            
    end

    local function footInteractions()
        local locationSum = Vector()
        local locationSumCount = 0
        for key, foot in pairs(feet) do
            
            if isValid(foot.attachedEntity) then
                foot.position = foot.attachedEntity:localToWorld(foot.localEntityVector)
            end
        
            
            local vector = foot.position - chairPos
            local dist = vector:getLength()
            local direction = vector/dist
            

            
                        
            
            
            local weight = 1
            local target = chairPos
            local color = Color(255,255,255)
            local scale = 0.3
            if dist < targetRadius then
                -- Too Close!
                target = chairPos + direction * (dist - targetRadius)
                weight = 5
                color = interpolateColor(dist/targetRadius, Color(255,0,0), Color(255,255,255))
                --sscale = 0
            elseif dist < (targetRadius + deadzoneRadius)  then
                -- perfect!
                --target = chairPos
                --weight = 1
                --color = Color(255,255,255) 
                --scale = 0
            elseif dist < (targetRadius + deadzoneRadius + stickyRadius) then
                -- too far! (pull back)
                target = chairPos + direction * (dist - targetRadius - deadzoneRadius)
                weight = 2
                local percentAway = (dist - targetRadius - deadzoneRadius)/stickyRadius
                color = interpolateColor(percentAway,Color(255,255,255), Color(0,255,0))
                --scale = 0.1
            else  
                removeFoot(key)
                continue
            end
            
            setTarget(target, weight )
            holos:setColor(foot.holo, color) 
            holos:setScale(foot.holo, Vector(scale,scale,scale))
            holos:setPos(foot.holo, foot.position)
            
            locationSum = locationSum + foot.position
            locationSumCount = locationSumCount + 1
        end
        local direction
        local angle
        if locationSumCount > 0 then
            local target = locationSum/#feet
            local vector = target - chairPos
            local direction = vector:getNormalized()
            local axis = direction:cross(chair:getUp())
            angle = chairAng:rotateAroundAxis(axis, 100)
        else
            angle = Angle()
            angle[2] = chairAng[2]
        end
        
        pdController:setTargetAng(angle) 
    end

                    
    
    --local sense = useSensors()
    hook.add("think", "sensors", function ()
        chairPos = chair:getMassCenterW()
        chairAng = chair:getAngles()
        sense()
        resetTarget()
        footInteractions()
    end)
    
    --movements
    local lastVector = Vector()
    
    local function getClampedVector(vec, maxMag)
    if vec == Vector() then return Vector() end
        local mag = math.min(math.abs(vec:getLength()), maxMag)
        local vector = vec:getNormalized() or Vector()

        vector:mul(mag)
        return vector
    end
    
    local lastMag = 0
    local lastVec = Vector()
    local lastPos = chair:getMassCenterW()

    timer.create("holoUpdate", 0.07, 0, function ()
        holos:foreach( function(index)
            holos:applyChanges(index)
        end)
    end)
-- add color change and make distance cheaper
        
        
    hook.add("think", "movements", function ()
        local target = getTarget()
        resetTarget()
        if not target:isZero() then 
            pdController:setTargetPos(target)
            pdController:simulate()
        end
    end)
    

    local driver
    local function set_driver(ply, vehicle, role)
        if vehicle ~= chair then return end 
        driver = role and ply
    end

    hook.add("PlayerEnteredVehicle", "SetDriver", set_driver)
    hook.add("PlayerLeaveVehicle", "SetDriver", set_driver)
    

    
    -- Map of inputs and their acceleration values / forces
    local inputs = {
        [IN_KEY.FORWARD] = Vector(1, 0 ,0),
        [IN_KEY.BACK] = Vector(-1, 0, 0),
        [IN_KEY.MOVELEFT] = Vector( 0, 1, 0),
        [IN_KEY.MOVERIGHT] = Vector(0, -1, 0)
    }
    local outputs = {}
    
    
    hook.add("KeyPress", "KeyPress", function(ply, key)
        if ply ~= driver then return end 
        if inputs[key] then
            outputs[key] = 1
        end
    end)
    
    hook.add("KeyRelease", "KeyRelease", function(ply, key)
        if ply ~= driver then return end 
        if inputs[key] then
            outputs[key] = 0
        end
    end)
    
    
    hook.add("Tick", "Update", function()
        driveDirection = Vector()
        for key, value in pairs(outputs) do
            driveDirection = driveDirection + inputs[key] * value
        end
        drivePos = chair:getMassCenterW() + driveDirection * 50
        --holos:setPos("driveHolo", drivePos)
    end)


end



