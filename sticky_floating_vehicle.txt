--@name Floating Vehicle
--@author Lil'Tugboat
--@include libs/criticalpd.txt
--@include libs/holo_manager.txt
--@shared
  
if SERVER then

    
    local translationGain = 500 -- Set to desired stiffness
    local rotationGain = 500 -- Set to desired rotational stiffness
    
    local sensorDensity = 30
    local targetRadius = 60
    
    local sensorSparsity = 20 --Degrees: lower = dense, higher = sparse
    
    local holoVisual = true
    
    ---------------------------------------------------------
    
    local lastMovement = Vector()
    
    
    -- helpers
    local EntityCriticalPD = require("libs/criticalpd.txt")
    local HoloManager = require("libs/holo_manager.txt")
    local holos = HoloManager:new()
    
        //async checks
    local function checkQ(n)
        return quotaAverage() < quotaMax()*n
    end
    
    local function yieldCheck()
        if not checkQ(0.95) then
            coroutine.yield()
        end
    end
    
    //Spawn things
    local chair = prop.createSeat(chip():localToWorld(Vector(0, 0, 100)), Angle(0, 0, 0), "models/props_interiors/furniture_couch02a.mdl", true)
    
    --chair:setMass(100)
    --chair:enableGravity()
        
    holos:create(
        "holoProxy", 
        chair:obbCenterW(),
        chair:getAngles(),
        "models/sprops/misc/axis_plane.mdl"
    )    
    
    holos:setParent("holoProxy", chair)
    

    holos:create(
        "moveVisHolo", 
        chair:obbCenterW(),
        Angle(),
        "models/sprops/misc/axis_plane.mdl"
    )   
    
    -- Sets up Physics stuff
    local physObj = chair:getPhysicsObject()
    local pdController = EntityCriticalPD:new(physObj, translationGain, rotationGain)
    
    -- sets up visualization    
    function interpolateColor(x)
        local repelColor = {255, 0, 0} -- Color at x = -1
        local NeutralColor = {255, 255, 255} -- Color at x = 0
        local AttachColor = {0, 255, 0} -- Color at x = 1
    
        local resultColor = {0, 0, 0}
    
        if x < 0 then
            local t = x + 1
            resultColor[1] = math.lerp(t, repelColor[1], NeutralColor[1])
            resultColor[2] = math.lerp(t, repelColor[2], NeutralColor[2])
            resultColor[3] = math.lerp(t, repelColor[3], NeutralColor[3])
        else

            local t = x 
            resultColor[1] = math.lerp(t, NeutralColor[1], AttachColor[1])
            resultColor[2] = math.lerp(t, NeutralColor[2], AttachColor[2])
            resultColor[3] = math.lerp(t, NeutralColor[3], AttachColor[3])
        end
    
        -- Create the color object (assuming a Color function exists that takes RGB)
        return Color(resultColor[1], resultColor[2], resultColor[3])
    end

    
    -- setup Sensors
    local totalSensorVector = Vector()

    local spinItteration = 0 
    
    local sensors = {}
    
    --[[
        isAttached = false,
        attachedEntity = nil,
        endPos = vector,
        localEntityVector = nil,
        localVector = localVector,
        localAngle = localVector:getAngle()
    ]]--
    
    
    local bin = {}
    local function resetBin()
        bin = {}
    end
    
    local function getBinName(angle)
        local pitch = (angle[1] + 90) % 360
        pitch = math.floor(pitch / sensorSparsity) * sensorSparsity
        
        local yaw = math.round(angle[2])
        yaw = math.floor(yaw / sensorSparsity) * sensorSparsity
        
        return pitch .. "," .. yaw
    end
    
    local function addSensorToBin(sensor)
        local binString = getBinName(sensor.localAngle)
        sensor.bin = binString
        bin[binString] = (bin[binString] or 0) + 1
    end
    
    local function binIsFull(sensor, max)
        if not bin[sensor.bin] then return false end
        return bin[sensor.bin] > max
    end
    
    
    local function randomAngle()
        return Angle(math.random() * 360, math.random() * 360, 0)
    end
    
    local function randomVector()

        local x = 2 * math.random() - 1
        local y = 2 * math.random() - 1
        local z = 2 * math.random() - 1
    
        return Vector(x, y, z)
    end
    
    local function resetSensor(index)
        local vel = chair:getVelocity()
        local dirtyNormalVel = Vector()
        if not vel:isZero() then 
            local maxVelNumber = math.max(math.abs(vel[1]), math.abs(vel[2]), math.abs(vel[3]))
            dirtyNormalVel = vel / maxVelNumber
        end
        local localVector = (dirtyNormalVel + randomVector()):getNormalized()
        local localAngle = localVector:getAngle()
        local vector = chair:obbCenterW() + localVector * targetRadius
    
        local sensor = {
            isAttached = false,
            attachedEntity = nil,
            endPos = vector,
            localEntityVector = nil,
            localVector = localVector,
            localAngle = localAngle
        }
        addSensorToBin(sensor)
        sensors[index] = sensor
    end
    

    
   -- local function 
    
    local function initSensors()
        for i = 1, sensorDensity, 1 do
            resetSensor(i)
            holos:create(i)
            holos:setModel(i, "models/holograms/hq_icosphere.mdl")
            holos:setScale(i, Vector(0.3, 0.3, 0.3))
        end
    end

    local function moveSensors()
        chairPos = chair:obbCenterW()
        for i = 1, sensorDensity, 1 do
            local sensor = sensors[i]
            if sensor.isAttached then -- if stuck
                if sensor.attachedEntity then
                    
                    sensor.endPos = sensor.attachedEntity:localToWorld(sensor.localEntityVector)
                end
                sensor.localVector = (sensor.endPos - chairPos):getNormalized()
                sensor.localAngle = sensor.localVector:getAngle()
            else -- if sensor
                
                sensor.localVector = (sensor.endPos - chairPos):getNormalized()
                sensor.endPos = chairPos + sensor.localVector * targetRadius
                sensor.localAngle = sensor.localVector:getAngle()

            end
            addSensorToBin(sensor)
            

            holos:setPos(i, sensor.endPos)
            holos:setAng(i, sensor.localAngle)
        end
    end
    
    initSensors()
    
    local targetVecTotal = Vector()
    local targetVecCount = 0
    local function setTarget(vector, weight)
        if not weight then
            weight = 1
        end
        targetVecTotal = targetVecTotal + vector * weight
        targetVecCount = targetVecCount + weight
    end
    
    local function getTarget() 
        if targetVecCount and targetVecCount == 0 then return Vector() end
        return targetVecTotal / targetVecCount
    end
    
    local function look(sensor)
        local tracer = trace.line(chair:obbCenterW(), chair:obbCenterW() + sensor.localVector * targetRadius * 2 , chair)
        if tracer.Hit then
            
            sensor.isAttached = true
            if tracer.Entity then
                sensor.attachedEntity = tracer.Entity
                sensor.localEntityVector = tracer.Entity:worldToLocal(tracer.HitPos)
            else 
                sensor.attachedEntity = nil
            end
        else 
           
        end
        sensor.endPos = tracer.HitPos
    end
    
    local function useSensors()
        targetVecTotal = Vector()
        targetVecCount = 0
        for i = 1, sensorDensity, 1 do
            local sensor = sensors[i]
            
            if binIsFull(sensor, 2) then
                resetSensor(i)
                break
            end
            
            look(sensor)  
            
            if sensor.isAttached then 
            holos:setModel(i, "models/holograms/hq_torus.mdl")   
            holos:setScale(i, Vector(1,1,1))
                local dist = (sensor.endPos - chair:obbCenterW()):getLength() - targetRadius
                if dist > targetRadius then
                    resetSensor(i)
                else 
                    local target = chair:obbCenterW() + sensor.localVector * dist
                    local weight = 1
                    if (dist < 0) then weight = 3 end
                    setTarget(target, 10 )
                    --holos:setColor(i, interpolateColor(dist / targetRadius))
                end

            else
                 holos:setModel(i, "models/holograms/hq_icosphere.mdl")
                holos:setScale(i, Vector(0.3,0.3,0.3))
                 
            end
        end
    end
    
    --local sense = useSensors()
    hook.add("think", "sensors", function ()
        resetBin()
        moveSensors()
        useSensors()
    end)
    
    --movements
    local lastVector = Vector()
    
    local function getClampedVector(vec, maxMag)
    if vec == Vector() then return Vector() end
        local mag = math.min(math.abs(vec:getLength()), maxMag)
        local vector = vec:getNormalized() or Vector()

        vector:mul(mag)
        return vector
    end
    
    local lastMag = 0
    local lastVec = Vector()
    local lastPos = chair:getPos()

    timer.create("holoUpdate", 0.07, 0, function ()
        holos:foreach( function(index)
            holos:applyChanges(index)
        end)
    end)
-- add color change and make distance cheaper
        
        
    hook.add("think", "movements", function ()
        local target = getTarget()
        if not target:isZero() then 
        
            holos:setPos("moveVisHolo", target)
            pdController:setTarget(target, Angle())
            pdController:simulate()
        end
    end)
    

--[[
    local driver

    local function set_driver(ply, vehicle, role)
        if vehicle ~= chair then return end 
        driver = role and ply
    end

    hook.add("PlayerEnteredVehicle", "SetDriver", set_driver)
    hook.add("PlayerLeaveVehicle", "SetDriver", set_driver)
    
    
    local velocity = 0
    local acceleration = 0
    
    -- Map of inputs and their acceleration values / forces
    local inputs = {
        [IN_KEY.FORWARD] = 10,
        [IN_KEY.BACK] = -8,
    }
    
    
    hook.add("KeyPress", "KeyPress", function(ply, key)
        if ply ~= driver then return end 
        if inputs[key] then
        end
    end)
    
    hook.add("KeyRelease", "KeyRelease", function(ply, key)
        if ply ~= driver then return end 
        if inputs[key] then 
        end
    end)
    
    
    hook.add("Tick", "Update", function()
    end)
]]

    
else
    if player() != owner() then
     return
    end

end



