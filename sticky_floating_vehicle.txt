--@name Floating Vehicle
--@author Lil'Tugboat
--@include libs/criticalpd.txt
--@include libs/hud_helper.txt
--@shared
  
if SERVER then
    local translationGain = 500 -- Set to desired stiffness
    local rotationGain = 500 -- Set to desired rotational stiffness
    
    local sensorDensity = 70
    local targetRadius = 100
    
    local sensorSparsity = 20 --Degrees: lower = dense, higher = sparse
    
    local holoVisual = true
    
    ---------------------------------------------------------
    
    local lastMovement = Vector()
    
    
    -- helpers
    local EntityCriticalPD = require("libs/criticalpd.txt")
    
        //async checks
    local function checkQ(n)
        return quotaAverage() < quotaMax()*n
    end
    
    local function yieldCheck()
        if not checkQ(0.95) then
            coroutine.yield()
        end
    end
    
    //Spawn things
    local chair = prop.createSeat(chip():localToWorld(Vector(0, 0, 100)), Angle(0, 0, 0), "models/props_interiors/furniture_couch02a.mdl", true)
    
    --chair:setMass(100)
    --chair:enableGravity()
        
    local holoProxy = holograms.create(
        chair:obbCenterW(),
        chair:getAngles(),
        "models/sprops/misc/axis_plane.mdl",
        Vector()
    )
    holoProxy:setParent(chair)
    


    local moveVisHolo = holograms.create(
        chair:obbCenterW(),
        Angle(),
        "models/sprops/misc/axis_plane.mdl",
        Vector(1, 1, 1)
    )


    
    -- Sets up Physics stuff
    local physObj = chair:getPhysicsObject()
    local pdController = EntityCriticalPD:new(physObj, translationGain, rotationGain)
    
    -- sets up visualization
    
    local holoManager = {
        create = function(pos, ang, model, scale)
            
        end
    
    
    
    }
    
    
    
    
    
    
    
    local hitHolos = {}
    
    
--[[
    local function spawnSensorHolos()
       
        return coroutine.create(function()
            for index = 1, sensorDensity, 1 do
                
                local hitHolo = holograms.create(
                    holoProxy:getPos(),
                    holoProxy:getAngles(),
                    "models/holograms/hq_icosphere.mdl",
                    Vector(1, 1, 1)
                )
                --hitHolo:setParent(holoProxy)
                table.insert(hitHolos, hitHolo)
                yieldCheck()
            end
        end)
    end
]]
    
    --local initHolos = spawnSensorHolos()
--[[
    if holoVisual then
        hook.add("think", "initHolos", function ()
            if coroutine.status(initHolos) ~= "dead" then
            
                    coroutine.resume(initHolos)
            else 
                hook.remove("think", "initHolos")
            end 
        end)
    end

]]


    function interpolateColor(component1, component2, weight)
        return component1 + (component2 - component1) * weight
    end
    
function getHoloColor(value)
    
    local colors = {
        [-1] = Color(255, 0, 0, 255), 
        [0]  = Color(255, 255, 255, 255), 
        [1]  = Color(0, 255, 0, 255) 
    }

    -- Directly return the color if the value is -1, 0, or 1
    if colors[value] then
        return colors[value]
    end

    -- Find the nearest known values and interpolate between them
    local lower = -1
    local upper = 1
    if value < -1 then
        lower, upper = -1, 0  -- Interpolate between red and white for values less than -1
    elseif value > 1 then
        lower, upper = 0, 1   -- Interpolate between white and green for values greater than 1
    else
        if value < 0 then
            lower, upper = -1, 0  -- Interpolate between red and white
        else
            lower, upper = 0, 1   -- Interpolate between white and green
        end
    end

    -- Calculate the interpolation factor (t)
    local t = (value - lower) / (upper - lower)

    -- Interpolate red, green, and blue components
    local r = math.lerp(t, colors[lower].r, colors[upper].r)
    local g = math.lerp(t, colors[lower].g, colors[upper].g)
    local b = math.lerp(t, colors[lower].b, colors[upper].b)
    
    -- Return the interpolated color
    return Color(r, g, b, 255)
end

    
    -- setup Sensors
    local totalSensorVector = Vector()

    local spinItteration = 0 
    
    local sensors = {}
    
    --[[
        isAttached = false,
        attachedEntity = nil,
        endPos = vector,
        localEntityVector = nil,
        localVector = localVector,
        localAngle = localVector:getAngle()
    ]]--
    
    
    local bin = {}
    local function resetBin()
        bin = {}
    end
    
    local function getBinName(angle)
        local pitch = (angle[1] + 90) % 360
        pitch = math.floor(pitch / sensorSparsity) * sensorSparsity
        
        local yaw = math.round(angle[2])
        yaw = math.floor(yaw / sensorSparsity) * sensorSparsity
        
        return pitch .. "," .. yaw
    end
    
    local function addSensorToBin(sensor)
        local binString = getBinName(sensor.localAngle)
        sensor.bin = binString
        bin[binString] = (bin[binString] or 0) + 1
    end
    
    local function binIsFull(sensor, max)
        if not bin[sensor.bin] then return false end
        return bin[sensor.bin] > max
    end
    
    
    local function randomAngle()
        return Angle(math.random() * 360, math.random() * 360, 0)
    end
    
    local function randomVector()

        local x = 2 * math.random() - 1
        local y = 2 * math.random() - 1
        local z = 2 * math.random() - 1
    
        return Vector(x, y, z)
    end
    
    local function resetSensor(index)
        local vel = chair:getVelocity()
        local dirtyNormalVel = Vector()
        if not vel:isZero() then 
            local maxVelNumber = math.max(math.abs(vel[1]), math.abs(vel[2]), math.abs(vel[3]))
            dirtyNormalVel = vel / maxVelNumber
        end
        local localVector = (dirtyNormalVel + randomVector()):getNormalized()
        local localAngle = localVector:getAngle()
        local vector = chair:obbCenterW() + localVector * targetRadius
    
        local sensor = {
            isAttached = false,
            attachedEntity = nil,
            endPos = vector,
            localEntityVector = nil,
            localVector = localVector,
            localAngle = localAngle
        }
        addSensorToBin(sensor)
        sensors[index] = sensor
    end
    

    
   -- local function 
    
    local function initSensors()
        for i = 1, sensorDensity, 1 do
            resetSensor(i)
        end
    end

    local function moveSensors()
        chairPos = chair:obbCenterW()
        for i = 1, sensorDensity, 1 do
            local sensor = sensors[i]
            if sensor.isAttached then -- if stuck
                if sensor.attachedEntity then
                    sensor.endPos = sensor.attachedEntity:localToWorld(sensor.localEntityVector)
                end
                sensor.localVector = (sensor.endPos - chairPos):getNormalized()
                sensor.localAngle = sensor.localVector:getAngle()
            else -- if sensor
                
                sensor.localVector = (sensor.endPos - chairPos+ randomVector()*0.1):getNormalized()
                sensor.endPos = chairPos + sensor.localVector * targetRadius
                sensor.localAngle = sensor.localVector:getAngle()
                
                sensor.holo = {
                    sensor.localVector * targetRadius
                    sensor.holoAng = sensor.localAngle
                    sensor.holoColor = 
                }

            end
            addSensorToBin(sensor)
            
            

--[[
            local holo = hitHolos[i]
            if not holo then
                holo = holograms.create(
                    sensor.endPos,
                    sensor.localAngle,
                    "models/holograms/hq_icosphere.mdl",
                    Vector(1, 1, 1)
                )
                hitHolos[i] = holo
            else
                holo:setPos(sensor.endPos)
                holo:setAngles(sensor.localAngle)
            end
]]
        end
    end
    
    initSensors()
    
    local targetVecTotal = Vector()
    local targetVecCount = 0
    local function setTarget(vector, weight)
        if not weight then
            weight = 1
        end
        targetVecTotal = targetVecTotal + vector * weight
        targetVecCount = targetVecCount + weight
    end
    
    local function getTarget() 
        if targetVecCount and targetVecCount == 0 then return Vector() end
        return targetVecTotal / targetVecCount
    end
    
    local function look(sensor)
        local tracer = trace.line(chair:obbCenterW(), chair:obbCenterW() + sensor.localVector * targetRadius * 2 , chair)
        if tracer.Hit then
            sensor.isAttached = true
            if tracer.Entity then
                sensor.attachedEntity = tracer.Entity
                sensor.localEntityVector = tracer.Entity:worldToLocal(tracer.HitPos)
            else 
                sensor.attachedEntity = nil
            end
        end
        sensor.endPos = tracer.HitPos
    end
    
    local function useSensors()
        targetVecTotal = Vector()
        targetVecCount = 0
        for i = 1, sensorDensity, 1 do
            local sensor = sensors[i]
            
            if binIsFull(sensor, 2) then
                resetSensor(i)
                break
            end
            
            look(sensor)  
            
            if sensor.isAttached then    
                local dist = (sensor.endPos - chair:obbCenterW()):getLength() - targetRadius
                if dist > targetRadius then
                    resetSensor(i)
                else 
                    local target = chair:obbCenterW() + sensor.localVector * dist
                    local weight = 1
                    if (dist < 0) then weight = 3 end
                    setTarget(target, 3 )
                    --hitHolos[i]:setColor(getHoloColor(dist / targetRadius))
                end

            end
        end
    end
    
    --local sense = useSensors()
    hook.add("think", "sensors", function ()
        resetBin()
        moveSensors()
        useSensors()
    end)
    
    --movements
    local lastVector = Vector()
    
    local function getClampedVector(vec, maxMag)
    if vec == Vector() then return Vector() end
        local mag = math.min(math.abs(vec:getLength()), maxMag)
        local vector = vec:getNormalized() or Vector()

        vector:mul(mag)
        return vector
    end
    
    local lastMag = 0
    local lastVec = Vector()
    local lastPos = chair:getPos()

    timer.create("holoUpdate", 0.2, 0, function ()
        for i = 1, sensorDensity, 1 do
            local sensor = sensors[i]
            local holo = hitHolos[i]
            --if not sensor[i] then return end
            if not holo then
                holo = holograms.create(
                    sensor.endPos,
                    sensor.localAngle,
                    "models/holograms/hq_icosphere.mdl",
                    Vector(0.5, 0.5, 0.5)
                )
                hitHolos[i] = holo
            else
                
                holo:setPos(sensor.endPos)
                holo:setAngles(sensor.localAngle)
            end
        end
    end)
-- add color change and make distance cheaper
        
        
    hook.add("think", "movements", function ()
        local target = getTarget()
        if not target:isZero() then 
        
            moveVisHolo:setPos(target)
            pdController:setTarget(target, Angle())
            pdController:simulate()
        end
        --local newMagnitude = sensorRadius - minSensorLength
        --local sensorVectorNormal = averageSensorVector:getNormalized()
        --sensorVectorNormal:mul(newMagnitude)
        
        
        --local targetVector = holoProxy:getPos() +  sensorVectorNormal
--[[
        chairDelta = chair:getPos() - lastPos
        
        targetLocalVector = getClampedVector(totalSensorVector, 20)
        targetLocalVector = -chairDelta * 10 + targetLocalVector
        
        hud:addText(2, "Delta Length",chairDelta:getLength() )
        hud:addLine(1, chair:getPos(), chair:getPos() + targetLocalVector, Color(0,0,255), "delta")

        
        hud:addText(1, "Move Length", targetLocalVector:getLength())
        
        --moveVisHolo:setPos(targetVector)
        
        --if minSensorLength < sensorRadius * 0.99 then 
            pdController:setTarget(targetLocalVector + chair:getPos(), Angle())
            pdController:simulate()
        --end
        lastVec = targetLocalVector
        lastMag = targetLocalVector:getLength()
        lastPos = chair:getPos()
]]
    end)
    

--[[
    local driver

    local function set_driver(ply, vehicle, role)
        if vehicle ~= chair then return end 
        driver = role and ply
    end

    hook.add("PlayerEnteredVehicle", "SetDriver", set_driver)
    hook.add("PlayerLeaveVehicle", "SetDriver", set_driver)
    
    
    local velocity = 0
    local acceleration = 0
    
    -- Map of inputs and their acceleration values / forces
    local inputs = {
        [IN_KEY.FORWARD] = 10,
        [IN_KEY.BACK] = -8,
    }
    
    
    hook.add("KeyPress", "KeyPress", function(ply, key)
        if ply ~= driver then return end 
        if inputs[key] then
        end
    end)
    
    hook.add("KeyRelease", "KeyRelease", function(ply, key)
        if ply ~= driver then return end 
        if inputs[key] then 
        end
    end)
    
    
    hook.add("Tick", "Update", function()
    end)
]]

    
else
    if player() != owner() then
     return
    end

end



