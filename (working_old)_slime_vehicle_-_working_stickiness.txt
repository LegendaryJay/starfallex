--@name Slime Vehicle - Working Stickiness
--@author Lil'Tugboat
--@include libs/criticalpd.txt
--@include libs/holo_manager.txt
--@server
  
if SERVER then

    
    local translationGain = 1000 -- Set to desired stiffness
    local rotationGain = 500 -- Set to desired rotational stiffness
    

    local sensorCount = 30
    local targetRadius = 50
    local deadzoneRadius = 10
    local stickyRadius = 20
    
    local degSensorSeparation = 45 -- how big a bin is
    local sensorDensity = 1 -- how many sensors can fit in a bin
    
    local holoVisual = true
    
    ---------------------------------------------------------
    

    
    local lastMovement = Vector()
    
    local driveDirection = Vector()
    local drivePos = Vector()
    
    -- helpers
    local EntityCriticalPD = require("libs/criticalpd.txt")
    local HoloManager = require("libs/holo_manager.txt")
    local holos = HoloManager:new()
    
        //async checks
    local function checkQ(n)
        return quotaAverage() < quotaMax()*n
    end
    
    local function yieldCheck()
        if not checkQ(0.95) then
            coroutine.yield()
        end
    end
    
    //Spawn things
    local chair = prop.createSeat(chip():localToWorld(Vector(0, 0, 100)), Angle(0, 0, 0), "models/sprops/geometry/sphere_42.mdl", false)
    local chairPos = chair:getMassCenterW()
    local chairAng = chair:getAngles()
    
    local feet = {}

    holos:create(
        "driveHolo", 
        chair:getMassCenterW(),
        Angle(),
        "models/sprops/misc/axis_plane.mdl"
    )
    holos:setParent("driveHolo", chair)
    holos:setScale("driveHolo", Vector(0.3,0.3,0.3))

       

    holos:create(
        "targetRadius", 
        chair:getMassCenterW(),
        Angle(),
        "models/holograms/hq_sphere.mdl"
    )   
    holos:setScale("targetRadius", Vector(2 * targetRadius,2 * targetRadius,2 * targetRadius), true)
    holos:setParent("targetRadius", chair)
    holos:setColor("targetRadius", Color(80, 120, 80, 150))       

    holos:create(
        "deadzoneRadius", 
        chair:getMassCenterW(),
        Angle(),
        "models/holograms/hq_sphere.mdl"
    )   
    local combinedRadius = (deadzoneRadius + targetRadius) * 2
    holos:setScale("deadzoneRadius", Vector(combinedRadius,combinedRadius,combinedRadius), true)
    holos:setParent("deadzoneRadius", chair)
    holos:setColor("deadzoneRadius", Color(80, 200, 80, 100))
    
    
    -- Sets up Physics stuff
    local physObj = chair:getPhysicsObject()
    local pdController = EntityCriticalPD:new(physObj, translationGain, rotationGain)
    
    -- sets up visualization    
    function interpolateColor(x, colorA, colorB)
        return Color(
            math.lerp(x, colorA[1], colorB[1]),
            math.lerp(x, colorA[2], colorB[2]),
            math.lerp(x, colorA[3], colorB[3])
        )
    end

    
    -- setup Sensors
    local totalSensorVector = Vector()

    local spinItteration = 0 
    
    
    --[[
        isAttached = false,
        attachedEntity = nil,
        endPos = vector,
        localEntityVector = nil,
        localVector = localVector,
        localAngle = localVector:getAngle()
    ]]--
    
    
    local bins = {}

    
    local function addToBin(binKey)
        bins[binKey] = (bins[binKey] or 0) + 1
    end
    
    local function removeFromBin(binKey)
        bins[binKey] = (bins[binKey] or 0) - 1
    end
    
    local function moveBins(fromBinKey, toBinKey)
        if fromBinKey == toBinKey then return end
        removeFromBin(fromBinKey)
        addToBin(toBinKey)
    end
    
    
    local function getBinName(angle)
        local pitch = angle[1]
        pitch = math.floor(pitch / degSensorSeparation) * degSensorSeparation
        
        local yaw = angle[2]
        yaw = math.floor(yaw / degSensorSeparation) * degSensorSeparation
        
        return pitch .. "," .. yaw
    end
    
    local function binIsFull(binName)
        return (bins[binName] or 0) >= sensorDensity
    end
    
    
    local function randomAngle()
        return Angle(math.random() * 180, math.random() * 360, 0)
    end
    
    local function randomVector()

        local x = 2 * math.random() - 1
        local y = 2 * math.random() - 1
        local z = 2 * math.random() - 1
    
        return Vector(x, y, z):getNormalized()
    end
    
    local function localTrace(localVector)
        return trace.line(chairPos, chairPos + localVector * (targetRadius + stickyRadius), chair)
    end 
    
    
    local targetVecTotal = Vector()
    local targetVecCount = 0
    
    local targetAngVecTotal = Vector()
    local targetAngVecCount = 0
    
    local function resetTarget()
        targetVecTotal = Vector()
        targetVecCount = 0
    end
    local function setTarget(vector, weight)
        if not weight then
            weight = 1
        end
        targetVecTotal = targetVecTotal + vector * weight
        targetVecCount = targetVecCount + weight
    end
    
    local function getTarget() 
        if targetVecCount and targetVecCount == 0 then return Vector() end
        return targetVecTotal / targetVecCount
    end
    
    local unusedHolos = {}
    local holoItt = 1
    
    local function createFoot(binName, entity, position)
        local foot = {
            binName = binName,
            position = position
        }
        if #unusedHolos == 0 then
            foot.holo = holoItt
            holoItt = holoItt + 1
            holos:create(foot.holo)
            holos:setModel(foot.holo, "models/holograms/hq_icosphere.mdl")
            holos:setScale(foot.holo, Vector(1,1,1))
        else
            foot.holo = table.remove(unusedHolos, #unusedHolos)
        end
        
        if entity then
            foot.attachedEntity = entity
            foot.localEntityVector = entity:worldToLocal(position)
        else 
            foot.attachedEntity = nil
            foot.localEntityVector = nil
        end
        addToBin(binName)  
        table.insert(feet, foot) 
    end
    
    local function removeFoot(key)
        foot = feet[key]
        holos:setScale(foot.holo, Vector(0,0,0))
        removeFromBin(foot.binName)
        --print(2)
        table.insert(unusedHolos, foot.holo)
        --print(3)
        table.remove(feet, key)
    end
    
    local function sense()
        remainingSensors = sensorCount - #feet
        for i = 1, remainingSensors, 1 do
            -- set direction
            local direction = randomVector()
            local directionAngle = direction:getAngle()
            
            -- check bin and quit if full
            local binName = getBinName(directionAngle)
            if binIsFull(binName) then return end
            
            -- see if it hits anything, otherwise quiet
            local tracer = localTrace(direction)
            if not tracer.Hit then return end
    
            -- create foot
            createFoot(binName, tracer.Entity, tracer.HitPos)
            
        end
    end

    local function footInterations()
        local locationSum = Vector()
        local locationSumCount = 0
        for key, foot in pairs(feet) do
            local vector = foot.position - chairPos
            local dist = vector:getLength()
            local direction = vector/dist
            
            if isValid(foot.attachedEntity) then
                foot.position = foot.attachedEntity:localToWorld(foot.localEntityVector)
            end
            
            
            
            local weight = 1
            local target = chairPos
            local color = Color(255,255,255)
            local scale = 0.3
            if dist < targetRadius then
                -- Too Close!
                target = chairPos + direction * (dist - targetRadius)
                weight = 5
                color = interpolateColor(dist/targetRadius, Color(255,0,0), Color(255,255,255))
                --sscale = 0
            elseif dist < (targetRadius + deadzoneRadius)  then
                -- perfect!
                --target = chairPos
                --weight = 1
                --color = Color(255,255,255) 
                --scale = 0
            elseif dist < (targetRadius + deadzoneRadius + stickyRadius) then
                -- too far! (pull back)
                target = chairPos + direction * (dist - targetRadius - deadzoneRadius)
                weight = 2
                local percentAway = (dist - targetRadius - deadzoneRadius)/stickyRadius
                color = interpolateColor(percentAway,Color(255,255,255), Color(0,255,0))
                --scale = 0.1
            else  
                removeFoot(key)
                continue
            end
            if isValid(foot.attachedEntity) and foot.attachedEntity:getClass() == "player" then
                weight = 100
            end
            
            setTarget(target, weight )
            holos:setColor(foot.holo, color) 
            holos:setScale(foot.holo, Vector(scale,scale,scale))
            holos:setPos(foot.holo, foot.position)
            
            locationSum = locationSum + foot.position
            locationSumCount = locationSumCount + 1
        end
        local direction
        local angle
        if locationSumCount > 0 then
            local target = locationSum/#feet
            local vector = target - chairPos
            local direction = vector:getNormalized()
            local axis = direction:cross(chair:getUp())
            angle = chairAng:rotateAroundAxis(axis, 100)
        else
            angle = Angle()
            angle[2] = chairAng[2]
        end
        
        pdController:setTargetAng(angle) 
    end

                    
    
    --local sense = useSensors()
    hook.add("think", "sensors", function ()
        chairPos = chair:getMassCenterW()
        chairAng = chair:getAngles()
        sense()
        resetTarget()
        footInterations()
    end)
    
    --movements
    local lastVector = Vector()
    
    local function getClampedVector(vec, maxMag)
    if vec == Vector() then return Vector() end
        local mag = math.min(math.abs(vec:getLength()), maxMag)
        local vector = vec:getNormalized() or Vector()

        vector:mul(mag)
        return vector
    end
    
    local lastMag = 0
    local lastVec = Vector()
    local lastPos = chair:getMassCenterW()

    timer.create("holoUpdate", 0.07, 0, function ()
        holos:foreach( function(index)
            holos:applyChanges(index)
        end)
    end)
-- add color change and make distance cheaper
        
        
    hook.add("think", "movements", function ()
        local target = getTarget()
        resetTarget()
        if not target:isZero() then 
            pdController:setTargetPos(target)
            pdController:simulate()
        end
    end)
    

    local driver
    local function set_driver(ply, vehicle, role)
        if vehicle ~= chair then return end 
        driver = role and ply
    end

    hook.add("PlayerEnteredVehicle", "SetDriver", set_driver)
    hook.add("PlayerLeaveVehicle", "SetDriver", set_driver)
    

    
    -- Map of inputs and their acceleration values / forces
    local inputs = {
        [IN_KEY.FORWARD] = Vector(1, 0 ,0),
        [IN_KEY.BACK] = Vector(-1, 0, 0),
        [IN_KEY.MOVELEFT] = Vector( 0, 1, 0),
        [IN_KEY.MOVERIGHT] = Vector(0, -1, 0)
    }
    local outputs = {}
    
    
    hook.add("KeyPress", "KeyPress", function(ply, key)
        if ply ~= driver then return end 
        if inputs[key] then
            outputs[key] = 1
        end
    end)
    
    hook.add("KeyRelease", "KeyRelease", function(ply, key)
        if ply ~= driver then return end 
        if inputs[key] then
            outputs[key] = 0
        end
    end)
    
    
    hook.add("Tick", "Update", function()
        driveDirection = Vector()
        for key, value in pairs(outputs) do
            driveDirection = driveDirection + inputs[key] * value
        end
        drivePos = chair:getMassCenterW() + driveDirection * 50
        --holos:setPos("driveHolo", drivePos)
    end)


end



